# Kafka

## Теория Акторов

Актор - объекты, живущие внутри системы и обменивающиеся сообщениями. Акторы общаются с другими Акторами в процессе 
обработки полученного сообщения. **Все сообщения от акторов приходят последовательно**.
Когда сообщение попадает внутрь актора, то изменяется его состояние.
Проводят аналогию - "акторы это человечки живущие внутри системы, обменивающиеся сообщениями".
Обычно акторам присваивают имена и акторы могут быть "внутри других акторов", например
"root", "root/partition1", "root/partition2", "root/partition2/object1" но это не обязательно.

### Event-sourcing

Это паттерн, в котором состояние системы сохраняется как последовательность событий.
Вместо хранения текущего состояния объекта(актора), система сохраняет все изменения, которые привели к этому
состоянию. Это позволяет восстановить любое состояние системы просто проиграв все события с начала.

- Состояние актора зависит только от поступивших сообщений и от их порядка.
- Повторив все сообщения - получится аналогичный актор.
- Нужно как-то ограничивать набор данных, так как в моменте их может стать слишком много

Например:

```java
class BankAccount {

    private List<Event> changes = new ArrayList<>();
    
    public void deposit(int amount) {
        apply(new MoneyDeposied(amount));
    }
    
    public void withdraw(int amount) {
        apply(new MoneyWithdrawn(amount));
    }
    
    private void apply(Event event) {
        changes.add(event);
        //Логика применения события к текущему состоянию
    }

    public int getBalance() {
        int balance = 0;
        
        for(Event event : changes) {
            if(event instanceof MoneyDeposited) {
                balance += ((MoneyDeposited)event).getAmount();
            } else if(event instanceof MoneyWithdrawn) {
                balance -= ((MoneyWithdrawn)event).getAmount();
            }
        }
        
        return balance;
    }
     
}
```

### Kafka и Акторы

- Из каждой партиции может читать только один консьюмер.
- Каждый консьюмер обрабатывает сообщение одним потоком.
- Сообщения в партиции хранятся столько, сколько нужно.
- Сообщения можно читать повторно.


### Саги

Сага — это паттерн управления распределенными транзакциями, который используется для обеспечения согласованности данных в микросервисной архитектуре. 
В отличие от традиционных транзакций, которые блокируют ресурсы до завершения всех операций, сага разбивает долгоживущие транзакции на серию более мелких, 
управляемых транзакций, которые могут быть выполнены последовательно и независимо друг от друга.

Создается отдельная микротранзакция на каждое мелкое действие внутри сценария.
Каждая микротранзакция может завершиться успешно - тогда передается управление по цепочке дальше,
а может завершиться неуспешно - тогда начинается процесс роллбека, где каждый сервис выполняет откат
в своей зоне ответственности и передает информацию о роллбеке на нижестоящий уровень.

Например, заказ:
1) Создать заказ
2) Оплатить заказ
3) Обновить информацию на складе
4) Доставка заказа

Есть два подхода:
- Оркестр - когда есть отдельный сервис, который руководит всей последовательностью и откатами.
- Хореографический - когда каждый статус знает, куда он должен обратиться дальше по цепочке и что делать в случае ошибки.