3.1. Общая схема аутентификации
При запросе:

Authentication Filter перехватывает запрос, извлекает учетные данные (например, HTTP Basic или Form Login).

Authentication Manager получает объект Authentication и делегирует его одному из AuthenticationProvider.

AuthenticationProvider выполняет проверку:
загружает данные о пользователе через UserDetailsService;
сверяет пароль через PasswordEncoder;
возвращает объект Authentication с ролями и статусом.

SecurityContext сохраняет результат для всего запроса.

3.2. Пользовательские детали (UserDetails)
Spring Security использует интерфейс UserDetails для представления сущности пользователя. Основные методы:

- getUsername() — уникальный идентификатор;
- getPassword() — зашифрованный пароль;
- getAuthorities() — роли и полномочия;
- isAccountNonExpired(), isAccountNonLocked(), isCredentialsNonExpired(), isEnabled() — статусные флаги.

Реализация по умолчанию: org.springframework.security.core.userdetails.User.

3.3. Сервис пользователей (UserDetailsService)
Контракт для поиска пользователя по имени:

```java
public interface UserDetailsService {
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```


Реализации:

- InMemoryUserDetailsManager (память);
- JdbcUserDetailsManager (JDBC и таблицы БД);
- собственные реализации (например, через JPA-репозитории).

3.4. Пароли и PasswordEncoder
Для сравнения паролей используется контракт PasswordEncoder:

- encode(CharSequence rawPassword) — кодирование (обычно хеширование);
- matches(CharSequence rawPassword, String encodedPassword) — проверка совпадения.

Рекомендованные реализации:

- BCryptPasswordEncoder (по умолчанию);
- Pbkdf2PasswordEncoder, Argon2PasswordEncoder, SCryptPasswordEncoder.

Использование обычного текста недопустимо.

3.5. Настройка пользователей
Примеры конфигураций:

In-memory пользователи:

```java
@Bean
public UserDetailsService userDetailsService(PasswordEncoder encoder) {
    UserDetails user = User.withUsername("john")
    .password(encoder.encode("12345"))
    .roles("USER")
    .build();
    
    return new InMemoryUserDetailsManager(user);
}
```


JDBC пользователи:

```java
@Bean
public UserDetailsService users(DataSource dataSource) {
    return new JdbcUserDetailsManager(dataSource);
}
```


Custom сервис:

```java
@Service
public class CustomUserDetailsService implements UserDetailsService {
private final UserRepository repo;

    @Override
    public UserDetails loadUserByUsername(String username) {
        return repo.findByUsername(username)
                   .map(u -> User.withUsername(u.getUsername())
                                 .password(u.getPassword())
                                 .roles(u.getRole())
                                 .build())
                   .orElseThrow(() -> new UsernameNotFoundException(username));
    }
}
```

3.6. Провайдеры аутентификации
AuthenticationProvider содержит бизнес-логику. Пример по умолчанию: DaoAuthenticationProvider.

Работает с UserDetailsService и PasswordEncoder.
Сравнивает введённый пароль с сохранённым.
Возвращает Authentication с ролями.

Можно писать собственные провайдеры (например, для аутентификации по токену или внешнему API).

3.7. Конфигурация аутентификации
Используется компонент AuthenticationManager. В Spring Boot 3+ рекомендуется конфигурировать через AuthenticationConfiguration:

```java
@Bean
public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
    return config.getAuthenticationManager();
}
```

Ключевые выводы главы

- Аутентификация в Spring Security строится на цепочке фильтр → менеджер → провайдер → сервис пользователей → кодировщик паролей.
- UserDetails и UserDetailsService — центральные точки для работы с пользователями.
- Пароли всегда должны храниться в зашифрованном виде, рекомендуется BCryptPasswordEncoder.
- Для разных сценариев можно использовать разные реализации провайдеров и сервисов.
- Архитектура гибкая: легко подменять реализацию под конкретные требования.