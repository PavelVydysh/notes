# Kafka

## Событийно-ориентированная архитектура или однонаправленная обработка событий

На примере онлайн магазина

Фасад кладет данные в кафку, сервиса пользователей читает данные и создает пользователя,
кладет сообщение в топик для эмейлов, сервис эмейлов читает сообщени и отправляет код активации,
после подтверждения сервис пользователей кладет сообщение в топик  для сервиса корзины 
и сервис создает корзину дял пользователя.

То есть вся система реагирует на действия. И отличием архитектуры является то, 
что пользователь не ждет завершения сценария. Система создает пользователя на фоне, пока пользователь
может выполнять другие действия. Здесь работает **eventual-consistency**.

Если произошел сбой в работе сервиса корзины, то пользователь при попытке добавить товар получит ошибку.
Соответственно при таком подходе нужно везде делать проверки на консистентность.

В **Event-driven** архитектуре возможна ситуация когда очередность событий нарушается.\
На примере отправки сообщения в чат:
Пользователь 1 отправляет сообщение, которое попадает в кафку, из кафки сообщение
читает сервис сообщений и отсекает сообщения по идемпотентности, после чего
отправляет сообщение в кафку, сервис уведомлений читает сообщение из кафки и отправляет
уведомление пользователю 2, пользователь 2 пишет в кафку, что сообщение было прочитано и 
сервис сообщений читает эти данные из кафки и передает пользователю.
Может быть такое что на первом этапе(Пользователь 1 пишет в кафку), соединение пролагало и
локальное хранилище хранит информацию о том, что сообщение не прошло, но на самом деле сообщение уже
идет по системе.\
Пользователь 1 попытается заново отправить сообщение в кафку(сервис сообщений сможет отсеять его по идемпотентности),
но ему уже приходит информация о том, что его "неотправленное" сообщение прочитано.
Поэтому нужно учитывать такие моменты.

Такая система подходит, если не нужен запрос-ответ. Если нужен запрос-ответ лучше использовать саги.