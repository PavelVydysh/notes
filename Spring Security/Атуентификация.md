### 1. Контракт Authentication — представление запроса аутентификации

Интерфейс Authentication расширяет Principal и содержит минимум: 
- набор полномочий (getAuthorities()), 
- учетные данные (getCredentials()), 
- дополнительные детали (getDetails()), 
- сам принципал (getPrincipal()/getName()), 
- флаг завершённости аутентификации (isAuthenticated()/setAuthenticated(...)). 

Это формализует событие аутентификации — входной объект для провайдеров.

Полезные замечания:

До установки флага isAuthenticated == true объект представляет попытку аутентификации (например, UsernamePasswordAuthenticationToken с паролем в credentials).

После успешной аутентификации возвращается объект Authentication, помеченный как аутентифицированный и содержащий полномочия; конфиденциальные данные обычно удаляются/не сохраняются в сессии.

### 2. AuthenticationProvider — обязанность и контракт

Контракт:

```java
public interface AuthenticationProvider {
    Authentication authenticate(Authentication authentication) throws AuthenticationException;
    boolean supports(Class<?> authentication);
}
```

Реализация authenticate() должна выполнить проверку и:

- бросить AuthenticationException при неуспехе (веб-фильтр вернёт 401),

- вернуть null, если тип объекта Authentication не поддерживается (позволяет последовательную проверку несколькими провайдерами),

- вернуть полностью аутентифицированный Authentication при успехе (с isAuthenticated() == true).

Роль supports(...): однозначно объявляет типы Authentication, которые провайдер способен обработать (обычно UsernamePasswordAuthenticationToken.class или его подклассы). Это даёт возможность иметь несколько провайдеров для разных схем.

### 3. Пример реализации провайдера (логика аутентификации)

Стандартный шаблон:

- Получение имени и credentials из authentication.

- Загрузка UserDetails через UserDetailsService.

- Сравнение поданного пароля с хранимым через PasswordEncoder.matches(...).

- При совпадении — создание UsernamePasswordAuthenticationToken (или другой реализации Authentication) с полномочиями; при несовпадении — бросить BadCredentialsException (наследник AuthenticationException).

Пример логики:

```java
String username = authentication.getName();
String password = authentication.getCredentials().toString();
UserDetails u = userDetailsService.loadUserByUsername(username);

if (passwordEncoder.matches(password, u.getPassword())) {
    return new UsernamePasswordAuthenticationToken(username, /*credentials*/ null, u.getAuthorities());
} else {
    throw new BadCredentialsException("...");
}
```

(в реальных приложениях credentials обычно не сохраняются в возвращаемом токене).

Регистрация провайдера: добавить в конфигурацию SecurityFilterChain вызовом http.authenticationProvider(authenticationProvider). Это подключает пользовательский провайдер в поток обработки аутентификации.

### 4. AuthenticationManager и процесс делегирования

AuthenticationManager (обычно ProviderManager) перебирает список AuthenticationProvider и:

- вызывает supports(...) у каждого; если провайдер поддерживает тип — вызывает authenticate(...);

- если провайдер возвращает Authentication — процесс завершается успешно;

- если ни один провайдер не вернул валидную аутентификацию или все выдали исключения — генерируется AuthenticationException (в итоге 401). Схема показана на рис. 6.4–6.6 главы.

### 5. SecurityContext и SecurityContextHolder — хранение аутентификации

Интерфейс SecurityContext прост: getAuthentication() / setAuthentication(...). Контекст хранит объект Authentication для текущего выполнения. SecurityContextHolder — менеджер/хранилище, реализующий стратегии хранения.

Стратегии хранения (SecurityContextHolder):

- MODE_THREADLOCAL — контекст на поток (типично для сервлет-приложений: один поток — один запрос);

- MODE_INHERITABLETHREADLOCAL — копирование контекста в дочерние потоки (полезно для @Async, как пишется в книге, по факту же работать не будет
т.к. при старте приложения создается пул потоков для  всех @Async методов, то есть поток создан до момента вызова);

- MODE_GLOBAL — один глобальный контекст для всех потоков (редко, обычно для автономных приложений).

Примеры доступа:

Явно:
```java
SecurityContext ctx = SecurityContextHolder.getContext();
Authentication a = ctx.getAuthentication();
```

Контроллер: принимать Authentication a в параметре метода (Spring внедрит текущую аутентификацию).

### 6. Проблемы и решения при работе с потоками (распространение SecurityContext)

Проблема: новый поток, созданный вручную или пулом, по умолчанию не видит контекст исходного потока → SecurityContextHolder.getContext() вернёт пустой контекст в новом потоке. Иллюстрация — рис. 6.8.

Решения, разбираемые в главе:

- MODE_INHERITABLETHREADLOCAL — наследование в дочерних потоках (подходит для @Async, если это приемлемо).


- Декораторы задач: DelegatingSecurityContextRunnable / DelegatingSecurityContextCallable<T> — оборачивают задачу и копируют текущий SecurityContext в поток исполнителя; примеры использования показаны.


- Декораторы пулов: DelegatingSecurityContextExecutor, DelegatingSecurityContextExecutorService, DelegatingSecurityContextScheduledExecutorService — оборачивают Executor(Serviсe) и обеспечивают автоматическое распространение контекста при отправке задач.

Практическая рекомендация (из главы): при создании «самоуправляемых» потоков использовать декораторы Spring Security для гарантированного копирования контекста.

### 7. HTTP Basic — конфигурация и тонкости

Простейшая регистрация: http.httpBasic(Customizer.withDefaults());. Это включает стандартный BasicAuthenticationFilter и обработку заголовка Authorization: Basic ....

Кастомизация HttpBasicConfigurer — через http.httpBasic(c -> { ... }). Возможности:

- realmName("NAME") — задать имя области (realm), которое появится в заголовке WWW-Authenticate при ответе 401;

- authenticationEntryPoint(...) — заменить точку входа при неаутентифицированном доступе.; WWW-Authenticate появляется только при 401.

### 8. Аутентификация на основе форм (formLogin)

Метод http.formLogin() автоматически настраивает базовую форму входа и выход (session-based flow). Возвращает FormLoginConfigurer<HttpSecurity> для детальной настройки (URL входа, успех/неудача и т. п.). По умолчанию выполняется редирект на оригинальный запрошенный путь.

Примеры настройки:

http.formLogin(c -> c.defaultSuccessUrl("/home", true)); — установка URL после успешного логина.

Для сложной логики обработки успеха/ошибки реализуются AuthenticationSuccessHandler и AuthenticationFailureHandler (аналогично для AuthenticationSuccessHandler).

Замечание архитектору: form-login использует серверную сессию для хранения SecurityContext → это менее предпочтительно для масштабируемых распределённых систем; в таких сценариях рассмотреть безсессионные подходы (OAuth2/JWT и т.д.), обсуждаемые в последующих главах.

### 9. Ключевые выводы (технически)

- Authentication — единая модель события аутентификации; возвращаемый аутентифицированный объект сохраняется в SecurityContext.

- AuthenticationProvider — основная точка внедрения пользовательской логики аутентификации; supports() и authenticate() определяют поведение и интеграцию нескольких схем.

- AuthenticationManager делегирует провайдерам; отсутствие успешной аутентификации приводит к AuthenticationException → 401.

- SecurityContextHolder управляет стратегиями хранения (THREADLOCAL, INHERITABLETHREADLOCAL, GLOBAL); для корректной работы с потоками применять декораторы/стратегии распространения контекста.

- HTTP Basic и form-login настраиваются через HttpSecurity (http.httpBasic(...), http.formLogin(...)); возможна тонкая кастомизация (realm, entry-point, success/failure handlers).